

Element: System
	eg) System.out.println("Hello, World!");
	- This denotes that the subsequent expression will call upon the System class, from the 
java.lang package.

java.lang package
	- Auto imported into every java program
	- contains classes and interfaces that are essential to the Java language.
	- primative types (boolean, int, float, byte, ect), and System, string, Thread


Element: (dot operator) .
eg) obj.toString(); 
	-Dot operators provide you access to a classes members; i.e. its fields
(variables) and its methods. 
	-'obj' is dereferenced. 
	-Dereferencing follows the memory address stored in a reference, to the place in memory where the 
actual object resides. 

Field  
	is a variable inside a class. 

Members 
	Variables, Methods, Inner class, or (the super class's constructor)
	
Literal:
	-A variable is a name that can represent different values during the execution of the program. 
	-A constant is a name that represents the same value throughout a program. 
	-But a literal is not a name -- it is the value itself.
	-A literal can be a number, a character, or a string. For example, in the expression,
		x = 3     x is a variable, and 3 is a literal.

Method Signature: 
	Name + parameters
	ex) public void setMapReference(int xCoordinate, int yCoordinate) { //method code }
	- setMapReference(int, int) is the method signature
	
bytecode:
		Bytecode is program code that has been compiled from source code into low-level code designed for a 
	software interpreter. It may be executed by a virtual machine (such as a JVM) or further compiled into 
	machine code, which is recognized by the processor.
		bytecode is compiled programming code that targets a virtual machine rather than a specific 
	computer architecture
		- if compiled into bytecode, then its a comiopled language (java, C)
		- if interpreted, then executing a program means reading the source file a line at a time, and doing 
	what it says
		- interpreted is where the instructions are not directly executed by the target machine, but instead 
		read and executed by some other program 

JVM:
	- Java Virtual Machine
	- A JVM is a software-based machine that runs Java programs. 
	- reads (interprets?) the compiled code, (bytecode) 
	- JVMs allow Java apps to run on almost any computer. Windows, OS X, and Linux 
	- similar to a physical processor. 
	- the Java code  from a .JAVA file must first be converted into instructions the JVM can understand.
		 called "bytecode,"

int: 2^15 (-,+)
double: 2^31 -,+
float: 32 bits
double 64 bits
long double 128



--------------------------------------------------------------------
	
- Javascript; Object based scripting (protype) language   
										| Java; OOP  language
- Javascript; Runs on a browser only.   | Java; Runs as an application, run on a virtual machine 
- Javascript; it is interpreted, not compiled. Every browser has a interpreter
										| Java; compiled and executed... machine code
- Javascript; event based 				| Java thread based 
- Javascript; DYNAMICALLY typed language | Java; STATICALLY typed language
- Javascript; Objects are PROTOYPE based | Java; Objects are class bassed, everything must be w/in a class
- Javascript easier to implement. 		 | Java faster, powerful
		https://www.geeksforgeeks.org/difference-between-java-and-javascript/

Prototype objects
	- Javascript
	- When already-created objects are cloned and reused to construct a program.
	- It uses a classless inheritance programming style in creating duplicate object instances.
	- Prototype-based programming is also known as classless programming or instance-based programming.
		https://www.techopedia.com/definition/30040/prototype-based-programming
	- class keyword is introduced in ES2015, but is syntactical sugar, JavaScript remains prototype-based
	- Polymorphism NO
	- Inheritance NO
	- Encapsualtioon Yes
	
	- class keyword is introduced in ES2015, but is syntactical sugar, JavaScript remains prototype-based
		
Statically typed language:
	- Java
	- the data type of a variable is known at compile time
	- all variables must first be declared before they can be used. 
	- Once declared to be of a certain data type, it cannot hold values of other data types
	- advantage: lots of trival bugs are caught at early stages
Dynamically typed languages: 
	- Javascript, Ruby, Python
	- variable types can change at run time. 
	- you dont have to specify the data type of the variable before compile time
	- advantage: faster programming

	
Scripting Language
	-  is a computer language with a series of commands within a file that is capable of being executed 
without being compiled
	-scripts: programs written for a special run-time environment that automate the execution of tasks
that could alternatively be executed by a human operator
	- are often interpreted (rather than compiled).
	- a programming language is typically compiled first before being allowed to run, 
	- scripting languages are interpreted from source code or bytecode one command at a time.

----------------------------------------------------------

Value: 
	- contents 
	- a number that has value to the programer
	- the representation of some entity that can be manipulated by a program
	
Reference: 
	- address, location,   
	- a value that enables a program to access a particular datum, such as a variable's value
	
Primativate data type - 
	- They are the most basic kinds of data types and they driectly contain values. 
	- 8 total: int, float, double, long, shot, byte, char, boolean
Object data 
	- programmer created types
	
	
Data Type
	- itentifies what type of data that an object can hold and what operations can be applied to it

---------------------------------------------------

Lambda
	- A function with no name.
	- An expression whose value is a function
	- Don't need to: declare the function somewhere else (and look for it later).
	- Naming something that you're only using once.
	Ex) args.foreach(arg => println(arg))
	- the argument to the foreach method is an expression for an anonymous function. 
	- lambda = anonymous function


Lambda's/anonymous

a convenient way of defining anonymous functions that can be passed as a variable to a method.
  Can also be passed to a method that accepts the delegate as a parameter

	
------------------------------------------------------

Subtyping
	- when a subclass object is used in place of it's superclass
	- Cat is a subtype of Animal, then Cat can be used wherever Animal is use
	
Enumerated
	- a set of named values
	- identifiers that behave as constants in the language.
	- implicitly public static final.
	
-------------------------------------
OOP
------------------------------------

Object Oriented Programing
	- organized around data. "data controlling acces to code"
	- in an OO langauge you define the data and the routines that are permitted to act on that data.
	
	- Purpose; To break large complex programs down into small simple pieces that work together
	- is the relationships and interactions between classes/objects, without specifying the final 
application classes/objects that are involved
	
	- Encapsualtion
	- Abstraction
	- Polymorphism
	- Inheritance

Class
	-the blueprints/template for objcts, and describes the state/behavior
	-State: properties of an object
	-Behavior
	-  used to model real-world objects you find in life

Object
	- instance of a class
	- operates on its "own" data structure
	- exists in memory
	- could be multiple, but only 1 class to describe all of it's objects

------------------------------------------------------------

POLYMORPHISM 
	- the programming language's ability to process objects differently depending on 
their data type. 
	- IS-A test is considered to be polymorphic.
	- method overloading 
	- method overriding
	- subtyping
	- (when the language accesses a object the code determines which exact type it is and calls the associated 
       code.)
	https://stackoverflow.com/questions/1031273/what-is-polymorphism-what-is-it-for-and-how-is-it-used

------------------------------------------------------------
ENCAPSULATION
	- a  mechanism that restricts access to the objects
	- allows you to encapsulate things that shouldnt be modified by other parts of your code
	- It a mechanism of wrapping the variables and the methods that act on the data together as a single unit

	Purpose: 
	- keeps code and data safe from outisde interferance and misuse.
	- prevents the data from being accessed from the outside
	- protect data
	- (flexible easier to change?)
	
	
	ex)
	- Java's basic unit of encapsulation is the class. ... package 2nd example
	- Access Modifiers (public private) ... define the visibility of classes, methods, and attributes 

--------------------------------------------------------------	
	
ABSTRACTION 
	- making the programming simpler, reduce complexity.
	- where you show only “relevant/essential” data and “hide” unnecessary details of an object from the user
	- "abstracting away the details"
	- generalizting, via abstract class & interface
	- Abstraction is about simplicity (removing & generalizing), Encapsualtioon is about security.
	
	- (providing only essential information about the data to the outside world, hiding the background 
details or implementation.)
	- abstraction increases our programing ability (finding commonalities in code then abstracting it, 
	  then can reuse that)

---------------------------------------
																		
INHERITANCE	: IS-A		
																
	- where one class acquires the properties (methods and fields) of another.
	- Purpose: You can reuse the fields of another class
	
	- Cannot have multiple inheritacnes of classes (C# & Java) ... Diamond problems		 	 
	- Subclasses inherit: 
		- public members
		- protected
		- (private fields/methods are still accessible by methods and innter classes)
	- Subclasses DONT inherit:
		- private members 
		- Constructors
		- members with the same name as the Parent class
	- Members = Variables, Methods, Inner class, or (the super class's constructor)
	
	- Recall: When you create an object, that object will inherit fields from all of the class's 
        superclasses.
	- methods or constructors of same field; problematic.
	- super class  = base class = parent class
	- subclass = derived class = extended class = child class
	- a super class is the parent class of a derived class
	
	-Subclass will have more methods and variables than super class
	-Subclass will inherit all the properties of the superclass except the 
        private properties of the superclass
	- SubClass IS-A SuperClass
	
	Ex)
	public class Animal {}
	public class Mammal extends Animal {}				
	public class Dog extends Mammal {}
	- Animal is the superclass of Mammal Class ... Mammal IS A Animal
	- Mammal is the subclass of Animal						
	- Dog is the subclass of booth Mammal and Animal ... Dog IS A Mammal
	
	Ex)
	- The subclass will have at least all the properties of the superclass.
	- Thus this is possible
	public class subClass extends mySuperClass { }
	
	mySuperClass x = new subClass();
}
----------------------------
INTERFACE
	- The set of behaviours/controls on an object.

	- Contains only the declaration of the members, no body 
	- Can contain: methods, properties, events, indexers (C#)
	- Can't contain: constants, fields, operators, instance constructors, finalizers, or types. No static
	
	- Could implement mutliple interfaces to a class
	- In Java, Static methods and Default methods could be used in an interface to define a methods body 
        in the interface. The purpose, so you dont have to change the class that implements the interfaec
	- Interfaces contain no implementation of methods. 
	- classes that implement interfaces must implement all its members.
	- A class or struct can implement multiple interfaces. A class can inherit a base class and also 
        implement one or more interfaces.

	- Below: The list Interface is implemented by ArrayList, LinkedList, Vecor and Stack classes, and more
		List a = new ArrayList();
		List b = new LinkedList();
		List c = new Vector(); 
		List d = new Stack(); 
	 
ABSTRACT CLASS
	- for the sole purpose of making a class a subclass of another.
	- can only be subclassed
	- cannot be instantiated
	- Abstract method is a method that is declared without an implementation 
		Ex)	abstract void moveTo(double deltaX, double deltaY); { }
	- (C#) virtual means that a method could overriden) .
	- (Java) all non-static methods are by default "virtual functions." 
		- Only final methods (cannot be overridden), along with private methods (which are not inherited)
			are "non-virtual".
	- (C#) Override - for each abstract method you must use the override keyword in the subclass that inherit the 
		abstract  classes
		
	- Yes, abstracts can have constructors. The constructor will be called when the subclass is instantiated.

		ABSTRACT VS INTERFACE
		- abstract extends only 1 | interface can have multiple
		- abstract can impliment it's members (eg methods) | interface cant
		- abstract can have variables (fields) | interface cant
		- abtract can have access modifiers (public, ect) | interface cant
		- abstract can inherit from other abstract classes OR other interfaces | interface only other interfaces 
		
		- interface shares behavior but not same code (abstract has some optionally code and some behavior)
		
  Abstract or Interface or (unmodified) Class
  - abstract or (unmodified) class is good if you want implemented code. Ie non-empty bodies
	- implemented code = reduce repeated code
  - abstract is useful if you do not want the class created.
  - interface is useful to describe behavior.
  - interface for bahavior among multiple classes but with different logic / implemenation
  -> Interfaces only share behavior (no code)
  -> abstract can share behavior, code
  -> Classes share clode but can be created
  
---------------------------------------------------------									

FINAL in Java (sealed in C#)
- "final" class 	to prevent inheritence, your class from being subclassed. 
- "final" methos 	to prevent overriding, prevent certain methods within your class from being overriden. 
- "final" variable	to create constants, prevent changes to a variable's value. A final variable can only be 
initialized once,

IMMUTABLE
 - is an object whose state remains constant
 - cannot be modified after it was created.
 - Contains:
	- class & data members are private final.
	- a constructor
	- Getters
	- No setters
 Immutable vs Final
 - final is just a keyword whereas Immutable is a pattern
 - By declaring a reference variable as final, we won’t get any immutability nature
 - final ensures that the address of the object remains the same whereas the Immutable suggests that we 
can’t change the state of the object once created.
https://www.geeksforgeeks.org/final-vs-immutability-java/

SINGLETON
- a class that can have only one object of itself
- Contains: 
	- private constructor (prevents instantiating the object )
	- public variable/setters
	- "getter" for the object (static  accessor method, ie, a factory method to return the class member)
	- creates  static object of itself (private static mySingleton st = null;)


Instance Initialization Blocks 
	- executed before constructors. 
	- They are executed whenever the class is initialized and before constructors are invoked.
	- They are typically placed above the constructors within braces.
	https://www.geeksforgeeks.org/instance-initialization-block-iib-java/
 

	


----------------------------------------------------

	NOT (quite) OOP

----------------------------------------------------

GENERICS
	- Allows you to make "generic" methods or classes to whatever type
	- Allows types to be a parameter to methods, classes and interfaces.
		- thus generic method can be called with arguments of different types
	- can processes objects without stating what type the object is.
	Pros:
	- Code Reuse: can write a method/class/interface once and use for any type we want.
	- Type Safety: Generics make errors to appear at compile time instead of run time
	Ex) public class Box<T> {...}
	
	Bounded Type Parameterized
	- accept types which extend/implement a class/interface, (Comparable)
	- ? = wildcard = any type
	- public static <T extends Comparable<T>> T maximum(T x, T y, T z) {  T max = x; ..... }
	- add(List<? extends Number> list) .... Upper Bounded Wildcards
	- add(List<? super Integer) .......... Lower Bounded Wildcard
	
	- Parameterized type - a class that deals with other objects without stating what type it is.
				     	 - types that take other types as parameters. 	


--------------------------------------------------------------


ACCESS MODIFIERS:

	Access Levels
	Modifier	
				This Class	Package	Subclass	Entire App
	public		Y			Y		Y			Y
	protected	Y			Y		Y			N
	no modifier	Y			Y		N			N
	private		Y			N		N			N

	The above can be interupted like this:
	- Protected: Variables, methods, and constructors, which are declared protected in a superclass can 
	be accessed only by the subclasses in other package or any class within the package of the 
	protected members' class.

PACKAGE
	-  A set of related classes and interfaces [organized] inside of a namespace
	-  bundle of related types (classes, interfaces, enumerations, ect) 
	-  software written in the Java programming language can be composed of hundreds or thousands of 
	    individual classes, 
	- keep things organized by placing related classes and interfaces into packages.
	This allows you, the programmer, to focus on the design of your particular application, rather than the 
infrastructure required to make it work.

----------------------------------------------------

STATIC
	- A static variable will get memory only once and retain its value
		- all objects that have a static variable will have same value
	- A static method can be invoked without the need for creating an instance of a class.
	- A static method can access static data member and can change the value of it.	
	- It makes your program memory efficient (i.e., it saves memory).
	
	- in Java only static inner classes
	- in C#, a static class cannot be instantiated... Because there is no instance variable, you access the 
members of a static class by using the class name it

--------------------------------------------------------
--------------------------------------------------------
---------------     STACK & HEAP        ----------------
--------------------------------------------------------
--------------------------------------------------------

STACK
	- data for current function call
	- A block of memory that holds:
		- references to other objects in the heap
		- local primatives
		- function's parameters 
		- return address
		
	- A new block (called stack frame) is created in the stack memory whenever a method is invoked
	ex) when the foo() method terminates, the memory for the method foo() is freed
	

	Heap memory is used by all the parts of the application whereas stack memory is used only by one thread of execution.
	Stack memory is short-lived whereas heap memory lives from the start till the end of application execution.
	
	
	The run-time stack consists of stack frames, 
	The run-time stack is responsible for program execution and function calls. 
	A stack frame contains all the data for one function call: its parameters, the return address, and its local variables. 

	The stack frame only exists during the execution time of a function, and so do the objects on the stack frame
	- stack frame a portion of memory allocated for a block of code, block of code = method?

	When you declare and instantiate an object. The actual object goes on the heap. What goes on the stack? The 
address of the object on the heap. C++ programmers would call this a pointer, but some Java developers are 
against the word "pointer". Whatever. Just know that the address of the object goes on the stack.
	
	
HEAP
	- holds all objects & its data
	- if you see "new [object] then it's going on the heap

JRE (Java Runtime Environment )
	-provides the minimum requirements for executing a Java application; it consists of the Java Virtual Machine 
		(JVM), core classes, and supporting files.	
	


int    *ip;    /* pointer to an integer */
double *dp;    /* pointer to a double */
float  *fp;    /* pointer to a float */
char   *ch     /* pointer to a character */



	
Shallow/Deep Copy
	
	- Deep copies duplicate everything. A deep copy of a collection is two collections with all of the elements in the 
		original collection duplicated (copies recursivly).
	- Deep: All object in the original is copied. So two completely separate objects will be created.
	- Shallow: Copies the references from the orignal in the new copy. They both point to the same thing
	
	
String Pool:
	-The string pool allows string constants to be reused, which is possible because strings in Java are 
        immutable.      




--------------------------------------------------------

--------------------------------------------------------

Design Patterns:
	- It is a template for how to solve a problem that can be used in many different 
situations/application or systems 
	- defines how it's done
	
MVC
	Model 	- Gets the data from the database or XML-file and processes it
			- responds to view and controller
	View	- UI, What the user sees
			- HTML/CSS
			- Templating engines
	Contoler- Takes user input 
			- Gets data from the model, passes data to the view
			- The controller accepts the requests and handles it!

Controller VS Router
	- Routers are part of the controller layer
	- Controller implements a »Controller pattern, 
		- Controller Pattern has these things/entities: 
			Dispatcher, Router, Action & more
	- Routing is the process of taking a URI endpoint decomposing it into parameters then determine which module, 
	controller, and action of that controller should receive the request.
	The router takes the request and decides which controller/controller methods will handle the request.
	The controller accepts the requests and handles it!
	
	
	- Controller pattern: requests are intercepted by controller and dispatched to individual Action Controllers based on 
the URL requested(that is routing request from Router).
			
MVC

    frameworks that uses MVC concpets
    - Flask
    - Ruby on Rails
    - Angular JS

    Model - Database
    - BUSINESS LOGIC
    - gets and sends data
    - interacts with dataase (SQL or NOSQL or XML or JSON)
    - manipulates data
    - communicat with controller
    - sometimes can update the view (depends on framework

    View - Client
    - The UI, what user see
    - HTML/CSS
    - Communicates with controller
    - Template Engines

    Controller - Server
    - COMMUNICATES BETWEEN Users/View and the Model
    - 'middle man'
    - Receives input (from view, clicking link, forms)
    - contoler interaction between the model and view (user clicks, etc)
    - Gets data from model ; passes data to the view
                
    Controller

    - Gets requets from View and sends to Model
    - Gets response form model and sneds to view

--------------------------------------------------------
REST
	- The implementation of the client and the implementation of the server can be done independently without 
	  each knowing about the other. 
	- This means that the code on the client side can be changed at any time without affecting the operation 
	  of the server (and visa versa)
	  
	- stateless : the server does not need to know anything about what state the client is in and vice versa.
	- client-server is all rest API
		
	GET 	— return 200 (OK)
	POST 	— return 201 (OK CREATED)
	PUT 	— return 200 (OK)
	DELETE 	— return 204 (NO CONTENT) 
	
REST API
	- the messenger that takes requests and tells a system what you want and then returns the response.
	- a piece of software that plugs one application directly into the data and services of 
	another, granting it access to specific parts of a server. 



API
	- APIs are the 'middle man', they can sit between your program and the hardware (or other software)
	- helps two different layers (software/hardware) talk to each other w/o having tons of code in common.
	- these software layers help standardize the programing process so program can interact with lots 
	of others easily
	-makes it possible for all the disparate devices and software work well with each other
	- device layer
		- APIs are used for communication between services
		- APIs let two pieces of software communicate
		- EX) An API for a website is code that allows two software programs to communicate with each another
		- APIs also control access to resources
		- APIs are also used to control access to hardware devices and software functions that an application 
		may not necessarily have permission to use. 
		- APIs often play a big role in security.

Driver
	- software that allows your computer to communicate with hadware or devices. (sound card)
	- very low level?

Processes and Threads
	- Processes are often seen as synonymous with programs
	- Threads exist within a process — every process has at least one. 
	- Threads share the process's resources, including memory and open files. 

--------------------------------------------------------

Firmware
	- Firmware is software written directly into our hardware devices.
	- Firmware is stored on flash ROM (special types of memory) 
		- written once, by the manufacturer 
	-exmpale
		There's firmware in computer motherboards (it's called BIOS or UEFI), there's firmware in hard disks, solid-state drives (SSDs), 
	CD/DVD/Blu-Ray drives, there's firmware in network cards, routers, access points, range extenders, there's even firmware in your 
	gaming mouse and keyboard. These are just some examples that are related to computers.
	
	
	Firmware vs Drivers
		- firmware on hardware
		- drivers installed on OS
		- firmware is stored on the hardware device itself while drivers are installed inside the operating system. 
		- Also, firmware can start on its own and do what it is programmed to do while drivers must be run by the operating system. 
		  The biggest difference between the two is that the firmware tells the devices what they should do, while the driver tells 
		  the operating system how to communicate with the same devices.
		- provides the low-level control for the device's specific hardware.

--------------------------------------------------------

CONTAINERS

	- provides isolated environments for running your software services.
	- create predictable environments that are isolated from other applications. 
	- Containers virtualize the operating system instead of hardware (VMs virtualize hardware). 
		- with multiple containers running atop the OS kernel directly. 
	- containers are far more lightweight: they share the OS kernel, start much faster, and use a fraction 
		of the memory  
	- allow you to package your application and its dependencies together into one succinct manifest that can 
		be version controlled
	- software dependencies: specific versions of programming language runtimes and other software libraries.


--------------------------------------------------------

Agile
	- iterative development
	- flexible, adaptive planning
	- frequenlt delievery
	- feedback, communication
	- face to face

Waterfall
	- progress and project phases are linear
	- development steps be taken throughout the software development
	
	
SOFTWARE AS A SERVICE
	- rent 
	- software is purchased as a subscription
	- the software is hosted on the cloud; accessed by the customer via internet, no worries about OS like mac
	- SaaS uses the web to deliver applications that are managed by a third-party vendor and whose interface 
is accessed on the clients’ side. Most SaaS applications can be run directly from a web browser without any 
downloads or installations required, 
	low risk for customer
	
	allows many businesses to exercise better and more predictable budgeting.
	SaaS removes the need for organizations to install and run applications on their own computers or in their own data centers.


Software Cycle
	- is a process that produces software with the highest quality and lowest cost in the shortest time
	- Requirement gathering and analysis -Meetings with managers, stake holders and users are held in order 
to determine the requirements
	- Design - specifying hardware and system requirements and also helps in defining overall system architecture
	- Implementation - work is divided in modules/units and actual coding is started. 
	- Testing - unit testing, integration testing, system testing, acceptance testing, non-functional testing 
	- Deployment 
	- Maintenance - problems comes up and needs to be solved
	
--------------------------------------------------------

Threads & Processes
	- Processes are often seen as synonymous with programs
	- Threads exist within a process — every process has at least one. 
	- a process is; memory space, code, data, and system resources. 
	- a thread is code that is to be executed serially within a process. 
	- a processor executes threads, process always has at least one thread of execution, known as the primary 
	- Threads share the process's resources, including memory and open files. 


SDK (Software Development Kit)
	- a set of software development tools that allows the creation of applications for a certain software 
package, software framework, hardware platform, computer system, video game console, operating system, or 
similar development platform
	- ex) visual editors or debuggers, chat SDK, or image SDKs

Protocol
		A protocol is a set of rules and guidelines for communicating data. Rules are defined for each step 
and process during communication between two or more computers. Networks have to follow these rules to 
successfully transmit data.
	
--------------------------------------------------------
C# and C++


DEBUG AND Release
	- Debug and Release are just labels for different solution configurations.
	- Release mode optimizes 
	- Debug generates debug data, in.pdb (Program Database File) files 

PREPROCESSOR DIRECTIVE 
	#IF DIRECTIVE
	- compiless the code between the directives only if the specified symbol is defined
	- followed eventually by an #endif directive
	- eg) #if (DEBUG && !MYTEST)
	
STA Thread
	- tells the compiler to use a Single Thread Apartment model
	- If not present, the application uses the multithreaded apartment model, which is not supported for Windows Forms.
	- used for Windows Forms (GUI's) as that uses Win32 for its drawing, which is implemented as STA. If you are using something that's STA model from multiple threads then you get corrupted objects
	- don't worry about it, just accept that Windows GUI threads must be marked as STA otherwise weird stuff happens

Win32 = Window's (API) for developing 32-bit applications,  available in the Microsoft WIndows operating systems

LAZY
	- “Lazy Instantiation” defers creation of an object till the time it is actually accessed.
	- Lazy Instantiation optimizes resources by using them when it is actually required
	- The process of object creation is always expensive as it involves allocation of memory on the heap.
	- when object creation is non-trivial (taxing)

COM (Component Object Model)
	- COM is a mechanism that was developed (by Microsoft) to allow people to distribute binaries that could be reused even if the 
		caller was using another vendor's C++/C# compiler or (ultimately) a different language altogether.
	- The essence of COM is a language-neutral way of implementing objects that can be used in environments different from the one in 
		which they were created, even across machine boundaries
	- COM is a platform-independent, distributed, object-oriented system for creating binary software components that can interact	
		it defines a binary interoperability standard for creating reusable software libraries that interact at run time. 
		libraries without the requirement of compiling them into your application.
ASSEMBLY
	- In C# terms, it's basically a single C# project.
	- An assembly is the compiled output of your code, typically a DLL or EXE 
	- Ttwo types: Private Assembly, Public/Shared Assembly, Satellite Assembly
		- Assemblies are the building blocks of .NET Framework applications; they form the fundamental unit of deployment, version 
control, reuse, activation scoping, and security permissions. An assembly is a collection of types and resources that are built to 
work together and form a logical unit of functionality.
	(Access modifiers article) .. All types and type members have an accessibility level, which controls whether they can be used from 
other code in your assembly or other assemblies
	https://stackoverflow.com/questions/2972732/what-are-net-assemblies
	https://social.msdn.microsoft.com/Forums/en-US/088ce8ed-ef9b-4dea-88b3-ca016885e26d/what-is-an-assembly-in-terms-of-c?forum=csharplanguage
	

BOXING (C#)
	- boxing and unboxing are computationally expensive processes.
	int i = 123;      // a value type
	object o = i;     // boxing
	int j = (int)o;   // unboxing
	
BOXING (JAVA)	
	Recall:
	Wrapper Class
		- eg) Integer, Float, Long  - vs - int, float, long
		      int x = 12   
		      Integer x = new Integer(x)
		- wrapper class "wraps" the functionaly of another class or component (to add functionaity to existing class w/o 
			using inheritance)
		- wrapper class has defined constants and methods (Integer.MAX_VALUE or Interger.equals() or 
			Integer.toHexademical() (or s/t)
		- some classes expect an object instead of a primative. eg, List<Integer> list
			
	AUTOBOXING & UNBOXING
	- the automatic conversion from a primitive types and their wrapper classes		
	- java compile does this automatically
	
	- Autoboxing  
		- wrapper to primative
		- compile converts 42 to an instance of an Integer class
			int ---> Integer
			Integer myInt = Integer(42)  <----autoboxing
			void coolMethod(Integer i) ....... coolMethod(41)  <----autoboxing			
	- Unboxing 
		- primative to wrapper
		   Integer ----> int
		- ex)
			Integer i = new Integer(44)
			if (i > 41)  <---- Unboxing i
			Integer intValue = null
			if (i > 41) <---- Unboxing i
			// gets null pointer  b/c this happens =>  if (myInt.intValue() <--- instance is null
		- primative only has it's value
		- many classes/methods expect an Object as a parameter.
		- ie List<Integer> list = new ArrayList<Integer>()
		-    list.add(51)

		
	- use primatives when possible
	- When we autobox or unbox a method is being called, this slows program.
	
-----------------------------------------------
Method Reference Operator 	(double colon)

 special type of lambda expressions, 
 - used to create simple lambda expressions by referencing existing methods.
 - used to call a method by referring to it with the help of its class directly.
 - can re ference a constructor in the same way that we referenced a method or constructor,
 - (ClassName::methodName)
 
 ex)
	List<Integer> numbers = Arrays.asList(5, 3, 50, 24, 40, 2, 9, 18);
	
	A)	numbers.stream()
		  .sorted((a, b) -> a.compareTo(b));
	   // Above can be rewritten as: 
	B)	numbers.stream()
		  .sorted(Integer::compareTo);
	  
 ex)	  
	class GFG { 
	  
		void someFunction(String s) 
		{ 
			System.out.println(s); 
		} 
	  
		public static void main(String[] args) 
		{ 
	  
			List<String> list = new ArrayList<String>(); 
			list.add("Geeks"); 
			list.add("For"); 
			list.add("GEEKS"); 
	  
			// call the instance method 
			// using double colon operator 
			list.forEach((new GFG())::someFunction); 
		} 
////////////////////////////////////////////////

	
Struct Vs Class
		- struct: all members are public by default
		- class: all members are private by default
		- classes are reference types and structs are value types
		- structures do not support inheritance
		- structures cannot have default constructor
		- Purpose: The general rule to follow is that structs should be small, simple (one-level) 
collections of related properties, that are immutable once created; for anything else, use a class.

DYNAMICALLY LINKED LIBRARY - DLL
	- A library of code 
	- could be used by 2+ applications at the same time 
	- links to an application when the application is run, rather than when it is created
	- application will each load the same copy of the DLL.
	- The libraries remain in their own files and are not copied into the executable files of the applications.
	
	- Uses fewer resources
	- DLLs aren't loaded into RAM when application starts
	- When a DLL is needed then it is loaded
	ex) 
		- the Printer-DLL is not loaded until the user prints a doc
		- COMDLG32.DLL − Controls the dialog boxes.
		- GDI32.DLL − Draws graphics, displaying text, and managing fonts.
		- KERNEL32.DLL − Manages memory and various processes.
		- USER32.DLL − Creates program windows and manages their interactions with each other.
	

	
	- static linking: library can be included within the application itself.	
		- makes deployment easier at the cost of flexibility as different 
		- However, static linking is not always an option. 
		- The user must have the .NET libraries in order to run a .NET application and libraries are loaded at runtime.			
 

HANDLE -
	- It is an  reference to a resource. 
	- used when application software references blocks of memory 
	- Common resource handles are file descriptors, network sockets, database connections, process identifiers (PIDs), and job IDs.
	- are obaque data types?


Delegates
	ex)
	public delegate int myDelegate(string s)

	- An object which holds a reference to a method 
	- A reference type variable that can hold a reference to the methods 
	- Can be the parameter of a method, in which a lamda could also be used (lambda is a delegate) 
	- Can be used to tell which method is to be called when an event is triggered.
	- Can be used as event handlers:
	  ex) https://www.tutorialsteacher.com/csharp/csharp-delegates (at mid/bottom)
 
Null-conditional operators: 
	?.  
	?[]
	If the object is not null, then continue.
	ex)
	  A) x = setOfPeople?.Count()
	  C) if (people != null)
			return people.Count()
		
Null-coalescing 
	  ??
	Returns the leftside if it is not null, else rightside
	ex)  
	  A) x = people ?? "default"
	  B) if (people != null)
	  return people
	  else
	  return "Default'"


BizHawk.Client.Common/rewind/rewinder.cs
Rewinder.cs

public bool RewindActive => RewindEnabled && !SuspendRewind;

private bool RewindEnabled { get; set; }

public bool SuspendRewind { get; set; }

public float FullnessRatio => _rewindBuffer?.FullnessRatio ?? 0;

public int Count => _rewindBuffer?.Count ?? 0;

public long Size => _rewindBuffer?.Size ?? 0;

public bool HasBuffer => _rewindBuffer != null;

public int RewindFrequency { get; private set; }





Sourcing a file is nothing but executing the file (line by line), but
The difference between sourcing and executing a file is : executing a file does not make any changes in the current shell

---------------------------------------

ENV
Environment variables hold values related to the current environmen


HOME
The user's home directory. On linux, ~ is shorthand for HOME.

PATH
The list of directories searched to find executable programs
directories in which executable programs (.exe) are located that can be started without typing the whole path to the file on the command line.
On Linux and Mac OS X, it holds all bin and sbin
On Windows, it holds C:\Windows and C:\Windows\system32 

PYTHONPATH
The list of directories that is added to Python's standard search list when importing packages and modules


PATH variable prevents us from having to write out the entire path to a program on the CLI every time we run it. Essentially, 
	it’s just a variable that stores a bunch of shortcuts.
When you enter a command without using the absolute path, the operating system checks the PATH variable. It reads through values 
	assigned to the PATH variable (seperated by ; or :) until it finds the value that contains the path to your program.

~/.bash_profile
       The personal initialization file, executed for login shells (used on start up, where you write your alias)
~/.bashrc
       The individual per-interactive-shell startup file (not used on )



API
Tip: keep backward compatibility so that if you change the API version, consumers get enough time to move to the next 
version.
TIp: should return JSON, old apps use XML


layered system - multiple layers of sw can be in the mix, in between client server
- client cant assume direct connection to server 
- improces scalability



web frameworks provide libraries for database access, templating frameworks, and session management, and they often promote code reuse.
webframeworks provide; security, routing, caching, url mapping, templating


-----------------
git for-each-ref --sort=committerdate refs/heads/ --format='(%(color:green)%(committerdate:relative)%(color:reset)) %(HEAD) %(color:yellow)%(refname:short)%(color:reset) - %(color:red)%(objectname:short)%(color:reset) - %(contents:subject) - %(authorname)'


[gets author + date]


git for-each-ref --sort=committerdate refs/heads/ --format='  %(committerdate:short) %(HEAD) %(color:yellow)%(refname:short)%(color:reset) - %(authorname) %cd ' ​

----------------------------------------

Dynamic types
	A dynamic type escapes type checking at compile time; instead, it resolves type at run time.
	dynamic dynamicVariable = 1;

	The object type can crash at run time if it is not converted to the correct data type. 
	It cannot show an error at compile time but it will show an error on run time.
	The actual type of dynamic would resolve at runtime. 
	- casting is required for objects

Implicily Typed Variable:
	- based on right side
	int i = 100;// explicitly typed 
	var j = 100; // implicitly typed

StringBuilder
	A memory optimized string-object. Doesnt create a new object in memory but instead appends.
	Strings will created new objects in memory

Namespace
	They organize large code projects.
	declaring your own namespaces can help you control the scope of your code



------------------------------------------------------------------------

LIBRARY VS FRAMEWORK

	Library
		- A library contains many pieces of functionality/stand-alone-code that you may pick and choose from 
		- It is a collection of objects/functions/methods your application links to
		
		ex) Network protocols, compression, string utilities, regular expressions, math. 

	Framework
		- You insert your code inot the framework.  The framework's code then calls your code at these points.
		- User still has code to link up but the most important work is done by the application.	
		- It provides a workflow that is hard to change (for better or worse). 
		- This means rapid development/prototyping, but if significant changes are made in the future it may be 
		  impossible (or very time consuming) to implement them.
	ex) Web application system, Plug-in manager, GUI system. 
	
	
-------------------------------------------------------------------

	.NET v C#

		- C# is a programming language, 
		- .NET is the framework that the language is run on.
		- C# is a language created for use with .NET.
	ASP v ASP.NET

		- ASP.NET is an extension of .NET
		- ASP is an older web framework and outdated technology, do not trouble yourself with it.	
		- Used for writing web-based applications and websites. 
		- ASP and ASP.NET are quite different under the hood.
	.NET 
		- .NET is used to develop Form-based applications, Web-based applications, and Web services.
		- .NET apps are in C#, F#, or Visual Basic.
		- Different .NET implementation do diffrent things:

	.NET Core 
		- should be used for cross-platform needs

		- should be used for containerized apps

		- high performance and scalability 
		- cross-platform for websites, servers, and console apps on macOS, Windows, and Linux.
	.NET Framework 
		- supports websites, services, desktop apps, and more on Windows.
		- Provides Windows forms  (ASP.NET Web Forms , Windows Presentation Foundation (WPF))
		
.NET Core offers significant benef(its for new applications and application patterns. However, the .NET Framework continues to be the 
natural choice for many existing scenarios and as such the .NET Framework isn't replaced by .NET Core for all server applications.

- A .NET application is platform dependent because of the .NET framework which is only able to run on the Windows-based operating 
system. The .Net application is platform independent also because of Mono framework

With .NET, you can use multiple languages, editors, and libraries to build for web, mobile, desktop, gaming, and IoT.





Partial Class

	A single class split into multiple files
	-  all files are combined into a single class file when the application is compiled. 

	-  partial keyword. 
	public partial Geeks 
	{ // code  }
	 combines Geeks1.cs and Geeks2.cs into a single file, i.e. Geeks

	PROS 
	With the help of partial class multiple developers can work simultaneously on the same class in different files.


Inline Method

	eg) [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.NoInlining)]
	- Inlining a method/property means that the compiler takes it and replaces the calls to it with its contents 

	- replaces a function call site with the body of the called function.
	- compiler optimization
	- improve performance

	- occurs during compilation, without changing the source code 
	- Related: (recommend the compiler to Inline via AggressiveInLining) https://www.dotnetperls.com/aggressiveinlining 

Attribute
	[ myAttribute]
	- square brackets
	- it associates metadata with code
	- Reflection: After associattion, the attribute can be queried at run time by using reflection
	SeializableAttribute:
		[System.Serializable]
		public class SampleClass
		{	
			// Objects of this type can be serialized.
		}

--------------------------------------------------------

volatile bool emulator_running = false;
public bool IsCrashed => !emulator_running;
	[...]
if(!api.IsCrashed)
		Frame++;
		

------------------------------------------------------------------------------	
	
/etc
	system wide configurations
	not user specfic config
	
/boot
	system boot
	where your system starts
	
/dev
	device
	keyboards, mice, network?

/bin
	binaries
	ls, cd, chmod
	
/lib
	library
	librarys that apps could use to provide various function
	
/mnt
/mount
/media
	other mounted drives
	floppy disk, usb, network drive, external hd, (A: or B: drive in windows)
	
/opt
	optional
	where manually installed sw from venders resides
	
/proc
	psudeo files that contain info about system processes and resources
	# cat  /proc/cpuinfo
	# cat /proc/uptime
	
/root
	the root user's home folder
	unlike users home folder it rsides not in the default home file
	root always has access to its home directory in this area
	
/run
	it runs in RAM, so everything is gone when the system restarts

/sbin
	system bin
	
/snap
	snap packed (used by ubuntu)
	
/srv
	service directory for syervice data
	if you run a server like ftp then it has better security

/sys
	system
	a way to interact to the kernal
	could make changes to graphics card
	
/tmp
	temporary
	files are temp stored by application
	an app might write to temp requently in case the app crashes
	is usually emptied on system restart
	
/usr
	apps installed by the user
	non essential for basic system operations
	
/var
	variable
	files that are expected to grow
	/var/crash holds info about stuff that crashed
	/var/log contains log files about many system
	
/home
	each user has own folder
	store personal documents
	store personal app's configs
	
	
---------------------
	DESIGN PATTERNS

https://www.tutorialspoint.com/design_pattern/



FACTORY
	- related to object creation
	- we create object without exposing the creation logic to client 
	- uses a static member-function (static factory method) which creates & returns (newly created) objects
	- Advantage: provides "code for interface rather than implementation."
	ex)	 ShapeFactory shapeFactory = new ShapeFactory();
		 Shape shape1 = shapeFactory.getShape("CIRCLE");
		 Shape shape2 = shapeFactory.getShape("SQUARE");
MVVC 
	- Model-view-ViewModel
	- essential, the view does extra work on the data
	- the ViewModel of MVVC s a value converter, meaning it is responsible for converting the data objects 
from the model in such a way that objects are easily managed and presented. 
	- the ViewModel is more model than view, and handles most if not all of the 
view's display logic

OBSERVER PATTERN 
	- a software design pattern 
	- an object (the subject), maintains a list of its dependents, (the observers), and notifies them 
automatically of any state changes, usually by calling one of their methods.
	-  in event driven software.
	https://www.geeksforgeeks.org/observer-pattern-set-2-implementation/

(LOOSE COUPLING)
	- is an approach to interconnecting the components in a system 
	- components depend on each other to the least extent practicable.
	- hardware and software may interact but they are not dependant on each other to work
	-The goal of a loose coupling architecture is to reduce the risk that a change made within one element 
will create unanticipated changes within other elements.
	- (network, hardware, software, or other functional components)


MODULAR PROGRAMMING

	- a software design technique that emphasizes separating the functionality of a program into independent, 
	interchangeable modules, such that each contains everything necessary to execute only one aspect of the desired 
	functionality.			


Single responsiblity principle
	- every class & method has a single responsiblty
	- makes it easy to quick and reason what each portion of the project is
	- if a class or method is doing too much and its hard to tell what it's doing
	
----------------------------------------------------------------------------



every one function sould have one entrance and one exit

command-query specation; every method should be either a command or a query, not both. The answer 
to a question should not change the answer

method should do 1 thing (but erroneously it does multiple things)

passing boolean into function is bad

high level methods should do high level work and not low level work

bean are classes that encapsulate many objects into a single object (thebean)

	
----------------------------------------------------------------------------
----------------------------------------------------------------------------
							NETWORKING
----------------------------------------------------------------------------
----------------------------------------------------------------------------


URL vs URI vs URN 
	- URI is URLs and URNs
		- nothing special about URI, it a word to say "URLs and URNs"
	- URL is by location 
		- URL is everything (protocol + domain + query + etc)
		- URL is usually what we talk about
	- URN is by name
		- not that popular
		
Networking Devices: 
	Modem
	Hub
	Switch 
	Router
	Gateway
	
hubs & switches are used to create networks
	- hubs are older and worse, not used often
	- hub & switches use mac address)
	
routers are used to connect networks
	- routers use IP address, thus it can talk to outside world
	
Gateway: interconnects different networks

	
	
modem 
	is what brings the internet into your house
	b/c there are only 2 types of signals
	A coputer only reads digital siganls
	the internet only reads analog singals
	signals to your comp: the modem demodulates the analog singals into digital signals
	signals from your comp: the modem modulates the digital signals into analog siganls.
		
	
NIC - Network Interface Card
	- the card that allows you to connect to the internet
	- manages network connection
	- fits into a slot in motherboard, or external port
	- often a cable (Cat5) connects NIC to another device OR a wireless thing built in computer
	- NIC is connected to a hub/switch

Peer 2 Peer - a singel cable between 2 computers (not common)	

networks usually require 3 pcies of hardware
	- Network card
	- cable
	- device to connect to 
	
HUBS, SWITCHES, and ROUTERS
	Hubs & Switches
		- Both used to create internal network
		- Both, the purpose, to connect all devices together on an internal network1
		- Both doesnt exchanged data to an outside network
		- Both does not read IP addresses
	Hubs: 
		- Not intelligent, b/c
		- when a data packet comes in one port then the same data packet is broadcasted to all other ports
		- secruity problems and wastes bandwidth
	Switch :
		- intelligent, b/c
		- learns physical address of connected devices 
			- ie, mac address is saved in a table
		- data packets are sent to targeted device
	Router 
		- forwards data from 1 network to another based on IP address
		- the router determines if the recieved data is for the router's (internal) network or another network
		- router = gateway of a network
	
WAN - Wide Area Network
	- a network over a lorge geographical area (corparations business in NY to LA)
		- Domain "Charter in NYC" to Domain "Charter in LA"
	- it connectes diffrent small networks(LANs)
		- so comps in one location can communicate w/ comps in ahtoer
		- building to building, town to town, city to city
		
NAT - Network Addres Translation
	- NAT Is used in routers
	- translate a set of IP addres to another set of IP address
	- helps preserve limited amount of IPv4 address
	- Recall:  when a computer talks to another computer it must translate its own private IP to a public IP, and visa vera, 
	- Private IP to public
	- Public IP to private

NAT v Router
  - Routing is the act of moving packets from one destination to another on different networks. 
  - NAT is the act of translating a private IP to a public 
IP to allow for the routing/communication with outside networks.
	
	
IPv4 - there are 2 types	
	- Public or Private
	- cannot access internet w/ private, your private is used internally/locally
	- your router gives your internal devices a private IP
	- public is publicly registered on internet, must have public IP to go on the internet
	- router will gives private IP address to your internal devies
	- the private IP will be tranaslted by NAT to public IP address
	- the public IP will be translated by NAT to private

HTTP - not secure
	 - data is sent in plain text
	 - hacker could listen to data (man in middle-ish)

HTTPS - encrypts the data
	 
TCP - data is in order
	- data packets have info about the order
	- to make sure that data delivery over a network is carried out correctly
	- Checksum, acknowledgement, order
	
UPD -	
	UDP cannot guarantee packet delivery.

	UDP is a faster and more efficient protocol than TCP because it dose not carry out all of the checks to make sure that the 
communication is perfect.

	UDP is ideal for time sensitive applications, where lost packets are not as important as delayed packets.
	
	UDP works well with application broadcast needs, e.g. ARP, and multi-casting, i.e. communicating with selected clients on the 
network.

	Common network applications that use UDP include:
		Domain Name System (DNS)
		Streaming media applications IPTV, i.e. watching TV on a computer system
		Trivial File Transfer Protocol (TFTP)
		Voice over IP (VoIP), i.e. using the network backbone and TCP/IP for telephone calls.


- Port is a logical connection used by programs & services to exchange information

Recall an REST API (one guy called it Business API)
	- simple for app developers
	- exposes data or services for public consuption
	- purpose: external app developers can use the API which grows the business.



Socket
	- A connection between two computers uses a socket.
	- Each end of the conecton will have a socket
	- socket = IP address plus port

	The connection to Google would be:
	(Your PC IP)+port 60200 ——– (Google IP) +port 80 (standard port)
	The connection to Yahoo would be:
	(Your PC IP)+port 60201 ——– (Yahoo IP) +port 80 (standard port)
	- 2 sockets per


Proxy Server
  - similar to broweser
  - when you look at a webpage it is stored in cache
  - a proxy server does rhe same
  - eg, if u want to retreied a webpage then when  a user wants to retreive a webpage it uses the cached

Broadcast -
	single transmitter of data to everything (wireless)
Unicast -
	data sent to a singl destimation
Multicast  
	data sent to multiple destimaiton at the same time

Routing Table: a table path that contian a set of rules that shows information on what path a data packet takes to its destination.
  - Destination, subnet mask, gateway, interface, next hop, metric.

Packet
	- recall, data is sent over the internet via small packets
    - Packet Switching: data take different routes to their destination (prob not in order), once all data arrives it is then then recompiled. 
	     Aka connectionless, most of internt uses switching
    - Circuit Switching: data takes same route, ie telephone lines.

VPN (Virtual Private Network)
	- provides a dedicated link between two points over the internet.
	- encrypts data
	- a vpn concentrator creates VPN connections & delivery
	- authenticates users, encrpts data and assigns tunnel / IP addresses
	- not necessary but used by organizations
	- originally used by business
	
-------------------------------------------------------------------------

MICROSERVICES
	Recall: service - repeatable business task
	- the archeticture of a program is broken into parts
	- Seperated into business logic chunks (eg, business might have Inventory Serivce, Shipping Service, Account 
Service)
	- API; services communciate to each other via APIs
	- if one microservice fails another service picks up
	- containerized
	Disadvantage
	- complex networking
	
	
note - Docker v VM
	- VM has a guest operating system
	- docker does not have a guest OS



MONOLITHIC- 
	- obstacle to scaling development. 
		- to update one component you have to redeploy the entire applicat
		- difficult for seperate teams to work independently (the UI team, accounting team, inventory team, etc.)
		- The teams must coordinate their development efforts and redeployments. 
	- compromise on the choice of hardware. ... memory database or cpu image processing
		
	disadvantages:
	- so big no one understand it
	- scalability
	- any small release or patch requires a full re-deployment of the application 
	https://docs.microsoft.com/en-us/dotnet/architecture/cloud-native/introduction
	
MICROSERVICE ARCHITECTURE

	- Each microservice performs a single task
	- microservice components are loosely coupled and communicate via APIs
	- apps are containerized
	- need Containerization Orchestrator (CO)
		- COs: Kubernetes, Azuere Container service, Amazon ECS, Marathon, Docker Swarm, Google Container Engine, 
	-  business logic is decomposed into a collection of small, loosely coupled, distributed components that collectively form the 
larger application. 
	- apps that follow MS arch are: 
		self-healing
		cost efficient
		easily updated and maintained through CI/CD.
		easy to automate the infrastructure 
		components should be stateless (user data)
	- An organization using  microservices architecture would take that shopping cart and break it up into smaller tasks. 
 Instead of a shopping cart application there might be a tax calculation service, an add/remove item service, a shipping 
 service, a billing service, and a compose final order service
 
	- expect an API gateway
	- An API gateway sits in front of an app and acts as a single point of entry for microservices.
		- it sends requests from API gateway to the microsevice back to user
	Kubernetes:
		- Node: 
			- Instance of a computer
			- it is running kubernetes, it is running a Kubelet (kubelet=application that communicates w/ master)
		- Pod:
			- 1+ container, exists on a node
		- Service:
			- Handels requres from inside or outside the cluster
			- Usually a load balancer
		- Deployment
			- Defines desired state 

			
-------------------------------------------------------------------------
									 
SERVICE ORIENTED ARCHETITURE (SOA)
 - when applications make use of services available in a network.
 - Each service performs a piece of business logic. 
	ex) Payment service (credit card) + User Authentication + Google's map service

 - a dev team might create an app by spliting the business logic into separate services, to be later integrated together.
 - or the dev team might use available services already created (google maps)
 

 Feature				SOA									Microservices
component size		large piece of business logic		single task or small piece of business logic
coupling			generally loosely coupled			always loosely coupled
			
-------------------------------------------------------------------------

Service Discovery
	- solves the problem of hardcorded URLs/addresses
	- how apps get the IP of the service
	- how services make their IP known for applications
	
  Service Registry 
	- is a database of available service instances
	
Client Side Service Discovery, 
  
	step 1) Client ---> Discovery Server 	 Service 1
			       <---				         Service 2
								             Service 3					 
									
	step 2) Client      Discovery Server       Service 1
			  |------------------------------> Service 2
				      					       Service 3					 
										  
	 - *The client finds the URLs*
	 - clients query the service registry, select an available instance, and make a request.
	 - the client finds the address by querying a Service Registry. The service registry responds w/ address
	 
	 - if service goes down the disc service will eventually be noticed
		 - if (the disc service) goes down, the client will use the cached data
		 
Server Side Service Discovery
  
    step 1)	Client ---> Discovery Server ----> Service 1
										 ----> Service 2
										 ----> Service 3					 
								 
	 - Client doesn't find a URL.
	 - Client sends message/data to a server (ie Server Side Service), and that server (which already has done the discovery 
	 work) then sends the message
	 - clients make requests to a discovery server which forwards the request to an available instance.
	 - less hops

	 AWS Elastic Load Balancer (ELB) is an example of a server-side discovery
	 
	 
Load Bs vs API Gateway
	- Load balancers and API gateways both handle network traffic
	- LBs distributes incoming network traffic
	- (Internet Request Traffic) ---> LB ----> Server 1 -
										 ----> Server 2 ----> Database
										 ----> Server 3 -

-------------------------------------------------------------------------
			
OSI Model (Open Systems Interconnection)

	- standard for communciation between computers or telecommunications
	- Computer A to Computer B; 
			- data flows down the OSI media and up again at 2nd computer
				- ComputerA: 7 to 1, 
				- Then network media (eg internet)
				- ComputerB: 7 to 1
			- 7. Application
			- 6. Presentation
			- 5. Session
			- 4. Transport
			- 3. Network
			- 2. Data Link
			- 1. Physical
	
			
n tier
  3 tier:
	- Presntaion layer 
		- UI, client
		- translate data/tasks to s/t the user can understand
	- Business/Logic layer
		- coordinates the commands recieved from the presentation layer
		- moves data from the presentation & data tier
		- makes logical decisions
		- calculates
	- Data Layer 
		- Queries and operations 
		- data is stored and retrieved
		
	
Integration testing 
	- modules are combined and tsested

Functional requirements 
	- what it should do, e.g 'process orders in x format...' 'y occurs every 24 hours' 'clicking a button starts z'
	
Non-functional requirements 
	- how it should perform e.g. 'process at least 200 orders a minute', or scalability, or security, type of 
database/language

Constraints 
	- what is out-of-scope to change 

----------------------------------------------------------------------------
	
DEV OPS
	- ppl in operations knoww what ppl in developmetn are doing
	- development: writes codes, features, tests
	- operations: manages servers, traffic, scaling, RAM, cloud 
	- devops manager mearges the deveopment & oper4ations together
 
 
 Clould Native Apps:
	- apps in the cloud that leverage all the greatness of the cloud which is primary micro services
	- applications and services built specifically to exist in the cloud.
	- Cloud-native applications are a collection of small, independent, and loosely coupled services.
	- Clould Native Apps ~=  Microservice archeticture
	- ppl keep mentioning Pets vs Cattle

 cloud native system, on the other hand, should be largely self-healing, cost efficient, and easily updated and maintained through 
Continuous Integration/Continuous Delivery (CI/CD).
 
 1 automation cloud makes it easier than ever to automate the infrastructure 
 2  design components to be stateless (user data)
----------------------------------------------------------------------------
SaaS	
	- On damand pay per use software
	- dont need to install SW on user's computer
	- the cloud runs an instance of the software
	- Developers build SaaS
	- End customers use SaaS
	- Google docs, MS 365
Paas
	- PaaS is IaaS + Operating System + mangment and business analytics
	- manage data and app resources
	
	- Windows Azure, Google app engine, heroku, AWS Elastice Beanstalk
	- Scaleable but developers are limted to the providers tools, and devs cannot migrate to another provider, 
	ie they are locked into the (AWS) vendor
	
IaaS
	- offers computing resrouces but in a virtual environment
	- resources like data storage, servers, networking, virtualization,
	- AWS EC2s, rackspace
	- 
Infrastructure
	- IaaS = Actual Computers/Data center + networking firewalls/security + storage
	- the resources built for you on the cloud
	- the devices you are working on; load balancer, VPNs,servers
	- ! the service part of it is the software mangement that lets you click/program 
	- AWS = IaaS
	- Platform = opearting system, programming language????
	
https://azure.microsoft.com/en-us/overview/what-is-paas/


	
----------------------------------------------------------------------------


JAVASCRIPT 

MAP
 - calls the  function once for each element in an array
 - like a for loop
 - returns an array!!
 - the .forEach() does the same but doesnt return an array


FILTER 
- calls a function that return array of elements which satisfy a test condition


REDUCE
- You have an array of amounts and you want to add them all up.
- It's weird and complex, dont invest time into this
ex)
	const euros = [29.76, 41.85, 46.5];
	const sum = euros.reduce((total, amount) => total + amount); 
	// 118.11
	

PROMISE
	- Used for async programming
	- 3 values: fulfilled, rejected, pending
	- a promise runs a block of code. 
		-that code is written by the programer so that when that code successfully finished it it will respond with 'resolve' and possibly 
			return data. 
		- If the code fails it will respond with 'rejected' and the reason why
	- the programer can use .then and .catch to write follow up code if the promise fulfills or rejects

	- "new Promise(function(resolve,reject) { code }"
	- resolve() in the promise is what will be returned in the ".then"
	- reject() in the promise is what will be returned to the ".catch" of the implimentation


	ex)

	  var promise = new Promise(function(resolve, reject) {
	  // do a thing, possibly async, then…

	  if (/* everything turned out fine */) {
		resolve("Stuff worked!");
	  }
	  else {
		reject(Error("It broke"));
	  }
	  });

	  promise.then(function(result) {
	    console.log(result); // "Stuff worked!"
	  }, function(err) {
	    console.log(err); // Error: "It broke"
	  });

EVENT
- actions that occur when a crietria is met
- bubbling: events propagate outwards, from the element -> it's parent -> parent's parent -> root
- capturing: events propagate in. root -> reaches the clicked element
- solution: e.stopPropagation()

AJAX
- not a language or tool
- it's web development technique used to send/retrieve data in the backgorund w/o refreshing
- it is the use of the XMLHttpRequest object to communicate with servers
-  most appealing characteristic is its "asynchronous" nature
 
HTML BODY:

	x-www-form-urlencoded:  simple text/ ASCII
							is the same as the one used in URL parameters.
	form-data: binary data or non-ASCII text
				same as <form>, data is key/value
				it’s the object to represent HTML form data.
				(in js) let fd = new FormData();
				
	Raw: A raw request can contain anything.  
		sends your raw string data as it is without modifications. 
		it will send plain text or JSON or any other kind of string
		The type of data that you are sending can be set by using the content-type header 
	Binary: non-textual data 
			video, audio, images
			
HTTP POST
	POST method sends data to the server. The type of the body of the request is indicated by the Content-Type header.
	
HTTP PUT
	for update
	
	

 Boiler Plate Code
	- boilerplate code" is any seemingly repetitive code that shows up again and again in order to get some result 
that seems like it ought to be much simpler. 
	- the programmer must write a lot of code to do minimal jobs.

Javascript
	Modules are JavaScript files. 
	they should pertain to some related functionality.
	Packages are 1+ modules. They are hosted by a package manager, like NPM
	
	
Maven
	- its a build and dependency managment tool
	- Group ID = package name 
	- Artifact ID = project name	
	
- Sourcing a file is nothing but executing the file (line by line), but
 - The difference between sourcing and executing a file is : executing a file does not make any changes in the current shell

	rnd note: 
	- you paste <script tags> in body tags (at bottom) b/c you dont want javascript to load prior to your css or the html
	- authentication refers to who you are, and authorization refers to what you can do.


----------------------------------------------------------------------------------

REACT JS

JS library for creating UI

Start up:
$ npx create-react-app myreactproject
$ cd myreactproject
$ npm start


React - page built on components
Redux - page built on a single tree/component, 1 single update


LET, CONST, VAR
	let - block scope, in braces {}
		- can be updated but not re-declared.
	const - block scope & constant
		  - cannot be updated or re-declared, must be initialized
	var - function scope
		- hoisted!!!
		- dont use

JSX
	- lets you write HTML-like code along side your Javascript code.
	- preprocessors (transpilers like Bable) to transform HTML-like code into javascript code which results in your React app
	- Assigning html element into variables is b/c of JSX
	- Mist have ONLY ONE top level element.
		ex) const myelement = <h1>I Love JSX!</h1>; 
		
	- Write expressions inside curly braces { }
		ex) const myelement = <h1>React is {5 + 5} times better with JSX</h1>; // 10

What is the difference between JS and JSX?
	- JSX = JavaScript Extension, mostly it will 
	- used along with reactJS. It is a combination of HTML and JavaScript. 
	- when react application loads the babel loader used to transpile the JSX to HTML and JavaScript.
		
		
PROPS
	- are passed to components via HTML attributes.	
		ex) const myelement = <Car brand="Ford" />;
		
	- are the variables of the class
	- defined in constuctor()
	- can pass data from one component to another, as parameters.
		1st) const carinfo = {name: "Ford", model: "Mustang"};
		2nd) return <Car brand={carinfo} />
		3rd) return <h2>I am a {this.props.brand.model}!</h2>;

PROPS vs STATE
	- both are plain JavaScript objects. 
	- props get passed to the component (like parameters) 
	- state is managed within the component (similar to variables declared within a function).
	
	- state is optional. increases complexity and reduces predictability, a Component without state is preferable. 

Why is setState giving me the wrong value?
	- In React, both this.props and this.state represent the rendered values, i.e. what’s currently on the screen.
	- setState are asynchronous - don’t rely on this.state to reflect the new value immediately after calling setState
	- Think of setState() as a request rather than an immediate command to update the component. For better perceived performance, 
	   React may delay it, and then update several components in a single pass. React does not guarantee that the state changes 
	   are applied immediately.
	- setState() will always lead to a re-render unless shouldComponentUpdate() returns false.

LIFECYCLE
	- Each component has a lifecycle of 3 phases:
	- Mounting, Updating, and Unmounting.
		Mounting - putting elements into the DOM. Four are methods are called.
		Updating - whenever there is a change in the component's state or props. Five methods are called.
		Unmounting - when a component is removed from the DOM. One method	


COMPONENTS
	- are independent and reusable bits of code that returns HTML
	- data is stored and handled using state and props.
	- Two types, Class-components and Function-components
		- functional components have:
			- no state
			- no lifecycle methods
			- no render method
			- is stateless
			- is a javascript function 
		- class compoenents:
			- has a state
			- marginally slower than function ( b/c creating class)
			- more code
			- has "extends React.Component" 
			- render method
			- will have "constructor()"
			
	Which one?
		Use functional if you can
		If your component needs some data which cannot be passed as a prop use class component to get that data. 
		If you need to keep UI state in your component(expandable blocks) 
	
OTHERS
	- Don't use var anymore
	- key is a special and reserved property in React
	- key cannot be referenced using this.props.key


Link vs a-tag
	- can do mroe with Link, a dynamic url with /page/:id
	- Link wont refresh page, a-tag will

	
random docker
	docker run -p 3306:3306 your-sql-container
	Will publish the 3306 port of your container to the 3306 port of your VM.
	Connection con = DriverManager.getConnection("jdbc:mysql://10.0.2.15:3306/databaseName","root","myrootpassword");
	
	
----------------------------------------------------------

useEffect()
	- 2 paramaters, 
		1st = code that runs when *it* renders/re-renders. 
		2nd = array of variables, if a variable is updated then useEffect is ran again 
	- triggers 1st param's code
	- If the 2nd argument is "[]" means 'only run after first render'


useState()
	- creates state variables.
	- useState returns 2 values, 
	- the variable & function to change that variable

useContext()
	- pass the state-data of a class between components. ie [name, setNames]


Other
	 - In React, props flow downward, from parent to child.
	 - The React philosophy is that props should be immutable and top-down. This means that a parent can send whatever prop values it likes 
	to a child, but the child cannot modify its own props. 

	- props are passed by parents to child component
	- a componentn should never modifity it's own props (it's immutable, so you cant)
	- state can be modifired using setstate and when value of state chagnes render is called


----------------------------------------------------------
SPRINGBOOT
- Spring Boot is an extension of Spring. 
- Makes development, testing, and deployment more convenient.
- To all the problems that arise from the Spring framework, Spring Boot is the solution. 
- faster and more efficient development eco-system.

- in CONTROLLER, it's a java class that maps a URI and an HTTP Method to some functionality (some methods)


SLF4J 
	- Simple Logging Facade 4 Java

	
----------------------------------------------------------
DEPENDENCY 
	- Class A uses methods from Class  B


DEPENDENCY INJECTION
	- di is arche design pattern
	- DI generally means passing a dependent object as a parameter to a method, rather than having the method create the 
		dependent object
	- thus the method doesnt have a direct dependecny on a particual implemenation
	- classic example: passing a database object in the parameters of a object
	 
	- makes code testable
	
	- prevents hard coding ... off loading the instatiation of some objects
	- Dep Inversion princ: rely on abstractons rather than concreted implemenations
	- abstract classes to interface, when we do, we decouple our implementations from each other
	-DI => Abstraction = more modular = more flexible

Inversion of Control = 
	- programming principle
	- the framework does most of the work. 
	- IoC determines what to inject into the code. 
	-User inserts his code (behavior and objects) into the framework. 
	-The framework calls your code (not visa vera)
	-in traditional programming, the custom code that expresses the purpose of the program calls into reusable libraries to take care of generic 
tasks, but with inversion of control, it is the framework that calls into the custom, 
	-when you have the power to call your code whenever you want that is library, otherhand, your framework calls your code	
	
	
-----------------------------------------

Cookies V LocalStorage vs SessionStorage
    - Cookies are mainly for reading server-side (very small)
    - local storage can only be read by the client-side
    - sessionStorage expires when the tab is closed!
	- Cookies carry information from one session on a website to another session	
	
-----------------------------------------
CORS (Cross Origin Resource Sharing)
	- security feature in browsers
	- prevents scripts on one website from making calls to another website.
	- used by browers to give web apps access to selected resources.
	- This restriction exists because requests made at other domains by your browser would carry along your 
		cookies which often means you'd be logged in to the other site. So, without same-origin, any site could host 
		JavaScript that called logout on stackoverflow.com for example, and it would log you out. Now imagine the 
		complications when we talk about social networks, banking sites, etc.
	- sends a pre-flight request to the server to determine if the browser origin is allowed to make requests
	- Access-Control-Allow-Origin: brodski-domain.com <== the server must set in response header.
	- cross domain check is performed by the browse
	
AJAX v XHR
	- AJAX allows async programing in the browser. 
		- not a single technology, but rather a group of technologies.
		- AJAX enables sending data in the background or recieving data and updating the page w/o refreshing.
	- XHR is the name of the object that browser use to send requests
	
API Key vs CORS
	- API Keys have limitations for a project, the server limits the projects use (ie, brodski.com is limited to 5,000/day)
	- CORS limit which domains could access the server 
	- CORS 
	
API keys are for projects, authentication is for users

Client ID : Is used to identify the application
Client Secret : This is the true secret key, which is stored on server side securely & not available to public

 Mine type:
	(google api) a request that uses the mine parameter must be authorized using OAuth 2.0
 
 -------------------------------------------------------------------
 
DEVELOPMENT, STAGE, PRODUCTION

	Development: 
		3 ppl writing code. After it looks good it moves to Stage environment. 
	Stage 
		is a little more robust than devlopement. It's close to production but not exactly b/c money. Want to test in Stage
		
 -------------------------------------------------------------------

Node server vs Apache
	- A node.js web application is a full-fledged web server just like Nginx or Apache.
	- Node is newer, which means newer ideas have been incorporated from the onset.
	- Apache is more mature, but slower to change.
	- The (node) http.Server module is now fairly well battle-tested on the internet to be trusted.

static & dynamic websites
	- dynamic websites recieve data from a server, and make modifications with the new data, which can vary from user to user.
	- It can display different content and provide user interaction, by making use of advanced programming and databases in 
	addition to HTML
	- Static websites are ones that are fixed and display the same content for every user


OracleJDK vs OpenJDK

	OpenJDK is an open source implementation of the Java Standard Edition
	OpenJDK is the official reference implementation for Java Standard Edition from Java SE 7.
	Oracle JDK’s builds from OpenJDK source code => no major difference

	 JDK - consists of JRE, tools to compile, debuging tools,.
	 JRE - consists of JVM, Java Pluging. (Doesnt contain compile tool or debug tools)
	 

-------------------------------------------------------------------------

UI:
						PROS								CONS
	Vanilla CSS 	Full Control							Slow dev b/c AF, build from scratch
					Name classes as you want				risks bad code

	Component 		Rapid Dev
	 Framework		Easy to learn/use						Low control
	 (Material, 											Unneccessary overhead code
	 BootSrap)												"all websites look the same"
	 
	 
	Utility			Faster Development (not as fast)		Low control
	 Framework		Fasy to learn							Unneccessary overhead code
	 (tailwind)		More options/customization

Responsive
	- the page adjusts intelligently to the screen's size

 
Native - Hybrid - Web App

	Native App = phone apps build for the specific phone type, ie Android or Apple 
	Hybrid App = phone apps that (sorta) are built for all phones (via WebView)
	Web App	   = traditional web pages. https://google.com

 

What is Materialize?
	- A CSS Framework based on material design.
	- materialize: library that lets you create websites based on google design concepts
	- Material-UI: React components for faster and easier web development. Build your own design system, or start with Material Design. 
	- React components for faster and easier web development. Build your own design system, or start with Material Design.
 
 robot.txt
  - a file read by web crawls. Usually for search engine crawlers
  
Static Website:
	- pre built pages are sent from the server
	- all pages are the same for each user
Dynamic Website:
	- pages are created for each reqeust on the server then sent 
	- pages use data from a database on the server
Single Page Website:
	- single page with a lot of javascript is sent from server
	- webpage/HTML re-renders itself using that javascript
	
	
	
-------------------------------------------------------
	
KOTLIN

-------------------------------------------------------

	$ kotlinc hello.kt -include-runtime -d hello.jar
    $ java -jar hello.jar
Overview
	- runs on the jvm
	- a bit faster than java
	- no Null Pointer Exception 
		- Kotlin's type system is aimed to eliminate NullPointerException
	- removes boiler plate code
	- designed with Java Interoperability in mind. 
		- Existing Java code can be called.
		- Existing Kotlin code can be used from Java as well. 
	fun function_name(param1: data_type, param2: data_type, ...): return_type
	- const is used for variables that are known at compile-time.
	- val is defined at run time
	
	
Access Modifier
	by default variables are public
	a module is a set of Kotlin files compiled together, ex) an IntelliJ IDEA module, a Maven project, & more
	
	internal - Accessible within the same modul
				This Class	Module		Subclass	Entire App
	public			Y		  Y            Y            Y
	protected 		Y		               Y            
	internal		Y		  Y                        
	private			Y
	
let, run, and with return the lambda result.
	let, in scope, "it" is the object. x.let { // it == x true}
	with, in scope, "it" is hidden. with(x) { add(55) == x.add(55) true}
	run is same as with, but written diff. x.run { add(55) == x.add(55) true}
	apply has no return type
	also in the code, you can read it as “and also do the following”.
	
	function	object reference
	let			it
	run			this
	with		this
	apply		this
	also		it

classes	
	- all classes are final by default 
	- use "open" keyword to allow a class to be inherited
	- if you override protected members without specifying modifier then they are by default protected	
	- Any class that extends an abstract class must implement all of its abstract methods and properties, 
		- (unless that class too is suppose to be an abstract class)	

	data class
		- simple class (kinda like a POJO)
		- gets rid of lots of boiler plate code
		- toString(), equals(), hashCode(), copy(), componentN() (N=1,2,3..) (getters and setters too duh)
		
	abstract 
		- no body, must be overridden by child
	
	interface 
		- You can have two methods with the same name	(when double inheritence)
			- in java you cannot
		- We can have code but not state.
			-  we can’t create a property and store the state in it
			- thid code is 'default implementation'

	Sealed class
		- new thing not found in java!
		- you have classes inside of the sealed class, each which inherit thee sealed class
		- google for more

					
	- By default nested classes are static so we can access the nested class property or variables 
		using captain.innerCapt().methodszz
	- Higher order function or higher level function can have another function as a parameter or return 
		a function or can do both.

Lazy
	the value gets computed only upon first access;
	- var pi: Float by lazy {
		3.14f
	}


Delegates (by keyword) 
	- achieves the same code reuse as inheritance.
	- like inheritence but w/o inheritence syntax
	- code reuseablity 
	- Storing Properties in a Map (https://kotlinlang.org/docs/reference/delegated-properties.html#storing-properties-in-a-map )

	(beginner) https://kotlinlang.org/docs/reference/delegation.html
	(advance) https://kotlinlang.org/docs/reference/delegated-properties.html

 ex)
	//use the map instance as the delegate for delegate property
	class User(val map: Map<String, Any?>) {
		val name: String by map
		val age: Int     by map
	}
	val user = User(mapOf(
		"name" to "John Doe",
		"age"  to 25
	))
	println(user.name) // Prints "John Doe"
	println(user.age)  // Prints 25

	
Observable
	- takes two arguments: the initial value and a handler for modifications. 
	- The handler is called after every time we assign to the property 
	- handler has three parameters: a property being assigned to, old value, new value
  ex)
	import kotlin.properties.Delegates

	class User {
		// use "Delegates.observable(intial value)  { // handler }"
		var name: String by Delegates.observable("<no name>") {
			prop, old, new ->
			println("$old -> $new")
		} }
	fun main() {
		val user = User()
		user.name = "first"
		user.name = "second" }

primary constructor 
	- has variables in params
	- part of the class header
	- can omit the constructor keyword sometimes
	- all the initialization logic is written inside "init" (initializer block)
	ex)
	class Human (n : String) {
		var name = n  }
	class Huamn2 (var n : String) //same as above
	
Secondary constructor 
	- uses constructor keyword inside the class body. good for inheritance 
	- can use secondary and primary together

	// just secondary constructor
	class Person { 
		var lastName: String
		constructor(lastName: String)  {
			this.lastName = lastName
		} }
		
	// both
	class Person(var lastName: String) {
		var age: Int? = null
		constructor(lastName: String, age: Int): this(lastName)  {
			//stuff
    } }	
	
----------------------------------------------------------------------------------
CQRS (Command Query Responsibitly Seperation)
	- command is a method that mutates state and 
	- query is a method that returns state. 
	- methods should either query data OR act on data, NOT BOTH

	- in microservices, a service might be split into query and write/action services
	
	Benefits:
	
	Independent scaling. 
		- CQRS allows the read and write workloads to scale independently
	Optimized data schemas. 
		- The read side can use a schema that is optimized for queries, 
		- the write side uses a schema that is optimized for updates.
	Security. 
		- It's easier to ensure that only the right domain entities are performing writes on the data.
	Simpler queries. 
		- By storing a read database, the application can avoid complex joins when querying.
	
	
Event Sourcing pattern. 

	 - application state is stored as a sequence of events. 
	 - Each event represents a set of changes to the data. 
	 - The current state is constructed by replaying the events. 
	 - In a CQRS context, one benefit of Event Sourcing is that the same events can be used to notify other components, eg the 
        read model. 
	 - The read model uses the events to create a snapshot of the current state, which is more efficient for queries. 
	 - github or multiplayer video game servers

Publisher - Subscriber Pattern

	 - messages published to a topic is immediately received by all subscribers to the topic. 

	 - publishers send messages 
	 - subscribers recieve messages
	 - publishers categorize messages into classes without knowledge of which subscribers, if any, 
	 - subscribers express interest in one or more classes and only receive messages that are of interest

----------------------------------------------------------------------------------
string immutable
	- As applications grow, it’s very common for String literals to occupy large area of memory, which can even 
cause redundancy. 
	- So the JVM sets aside a special area of memory called the “String constant pool“, in order to make Java 
more efficient

	- When the compiler sees a String literal it looks for the String in the pool. 
		- If a match is found the reference to the new literal is pointed to the existing String (so no new 
String object is created) 
	- The existing String now has one more reference. Here comes the point of making String objects immutable:

	- In the String constant pool, a String object is likely to have one or many references. 
	- Sine several references could point to same String, it would be bad if one of the references modified 
		that String value. That’s why String objects are immutable.

	- StringBuilder is mutable (jav and C#)


Final/Const vs Immutable
	- cosnt for javascript 
	- final for java
	- const keyword doesnt exist in java, keyword final not in javascript
	
	
	- final is a keyword 
	- Immutable is a pattern.
	- Final means that you can't change the object's reference, but you can still mutate its state (using setter methods e.g). 
	- Final ensure that the address of the object remains the same. 
	- const (and final) are not immutable for non-primative types
	- Immutable means we can't change the state of the object once created.
	- use final for non-object varibles is good
	- use immutable pattern for objects is good
	
	- KOTLIN 
	- final vs const:
		- final is used only for methods (prevent overriding)
		- const is used for variable's known at compile time (known before)
		- val is used for variables who's value is calcuated at run time  (known during)
			- both const and val never change after initialized
		- By default, Kotlin classes are final


-----------------------------------------------------------------

ANDROID

Android Framework
	- The android framework is the set of API's that allow developers to quickly and easily write apps for android phones
	- This procedure of developing the applications on Android platform in java programming language using the tools and API 
		libraries provided by Android SDK is called as Android Application Framework.

Activity 
	- a screen
	- An activity is a window in which the app draws its UI.
	- is java code + xml
	- when opening other activities (screens) these activities will go through the same 3 states when they are 
        opened.
	- When one app invokes another, the calling app invokes an activity in the other app, rather than the app as 
        an atomic whole
	- This window typically fills the screen, but may be smaller than the screen and float on top of other 
        windows. 
	- Generally, one activity implements one screen in an app.
		- one of an app’s activities may implement a Preferences or a Select Photo screen.
	- Most apps contain multiple screens/activities, the main activity is the first screen to appear when the 
        user launches the app. 
		- Each activity can then start another activity in order to perform different actions.
	- use your manifest file
	
Intent
	- A request for an action to perform
	- an implicit request tells the system to “Start a Send Email screen in any activity that can do the job." 
	- Verify there is an app to receive the intent 
		- app will crash if NOTHING CAN RECIEVE!	
Fragment
	- A Fragment represents a behavior or a portion of the UI
	- You can combine multiple fragments in a single activity to build a multi-pane UI and reuse a fragment in multiple activitie
	- A fragment must always be hosted in an activity 
	- the fragment's lifecycle is directly affected by the host activity's lifecycle. 
		- when the activity is paused, so are all fragments in it, 
	- fragment elements are useful b/c you can have a tablet that shows 2 fragments then have a phone that shows 1 fragment 
		divided accross 2 pages

Context
	- Context represents environment data.
	- it identifies where the programmer is in the app and how to communicate with the rest of the app.
	- Interface to global information about an application environment
	- It provides access to things such as databases, loading a resource, launching a new activity, creating views.
	- allows access to application-level resources and classes, & operations such as launching activities, broadcasting and 
		receiving intents, etc
	- consider: "TextView tv = new TextView(this);"
		- The keyword "this" refers to the context of the current activity.

JobScheduler
	- does background jobs
	- does jobs during relative times like: when charging, idle, network is active, every 10 min when network
	- very smart api
		
IntentService
	- s/t tht can perform the task that the intest requested
	- Sevices that handel Intent request and process the work
	- does work while user can still interact w/ device

BroadcastReceiver
	- Recieves an Intent from a sendBroadcast method often indication that soem work has been completed
	- 'hey i'm done w/ something'
	
Service
	- does something in th backgroudn even when user is not interacting with your app
	- its not a thread, dont use service when you should use a thread
	- must use explicit intent 
	- uses your application's main thread by default, which can slow the activity
	When a service is started, it has a lifecycle that's independent of the component that started it
	Foreground Service 
		- performs some operation that is noticeable to the user. 
		- must display a Notification
		- eg) an audio app would use a foreground Service to play an audio track. 
		
	
User Agent String 
- in android, A UserAgent is just a string that is generated for you based on the given application name and 
library version.

- information about that your browser passes to servers/websites, benign info about the browser itself
- this info is used to optimize the user experience
	- what web browser
	- screen resolution
	- if javascript is enabled
	- ect
	
UI runtime changes (rotating & stuff)
	- not best idea to use "android:configChanges"  b/c the OS might restart your app for many more reasons than just it being in 
background (memory ect)
	https://developer.android.com/guide/topics/resources/runtime-changes#HandlingTheChange
	

Storage
	Internal vs External
		Internal storage 
			- private
			- created by Android OS for your app
			- only be accessible from the app
			- no other app, or even the user, can see what's in the folder.
			- always available on all devices, more reliable
			- small size
			- getFilesDir() => data/data/app_packageName
		External Storage
			- possible to be accessed by other apps 
			- though data public, the files stored in these directories are meant for use only by your ap
			- can be a removable storage media (such as an SD card) or an internal (non-removable) storage
			- Removable volumes, such as an SD card, appear in the file system as part of external storage. 
				- Android represents these devices using a path, such as /sdcard.
			- getExternalFilesDirs 
			
			- If you specifically intend to create files that other apps should be able to access, your app should store these files 
in the shared storage part of external storage instead.
	- Int & Ext data gets deleted with your app (dont store camera photos here)
	
	Enironment returns user data directory. And getFilesDir returns application data directory
	
	Context.getFilesDir() returns a path that is bound to your package and the Context is required to access the package name.

	getContentResolver() - does SQL-like selections
Environment is different as there's only constants that are common to all apps running on the same runtime.

Fragment: onCreate vs onCreateView
	onCreate 
		- called on initial creation of the fragment. You do your non graphical initializations here. It finishes even 
		before the layout is inflated and the fragment is visible.
		- anything else that doesn't involve the View hierarchy
	onCreateView 
		- called to inflate the layout of the fragment i.e graphical initialization usually takes place here. It is always 
		called sometimes after the onCreate method.
		
Bundle vs Extras
	- both are key value 
	- bundle is faster
	- bundle can be a stand alone object.
	- extras are attatched/binded to the intent
	- bundle is often recieved
	- extras is often sent
	- bundle; you create a seperate bundle object then attatch & send. 
	- fragment.arguments = bundle
	-  intent.setExtras
	
Styles:

we are inheriting built-in platform style Widget.TextView using parent attribute in <style> element.
. To inherit our styles we don’t need to use parent attribute instead, we can use dot notation 

From styles outside: <style name="TextviewStyle" parent="@android:style/Widget.TextView">
From our styles: <style name="TextviewStyle.Blue">
		
//REACT_APP_SPRINGB_ADDRESS='https://customyoutube.com:8443'

Comparable vs Comparator
	- both interfaces
	- custom sorting logic for your objects or any other object
	Comparable
		- implements compareTo(myClass y)
		- enables custom comparison logic for your objects that you control
		- Song, Person, Bicycle
		- collections.sort(Song) will use your Comparable, your compareTo()
		- inorder to sort, the sort() method calls .compareTo(), but the class must implement Comparable first
			ex) public class Runner implements Comparable<Runner>
		- but if youre using someone elses library then you cant access Runner, then cant use Comparable :(
		- "this" used
		- "this.name.compareTo(o.name)"  vs "obj1.name.compareTo(obj2"
		
	Comparator
		- enables custom comparison logic for data-types tha you have no control over
		- Int, String, Long, etc
		- You can call Collections.sort(List<T>, Comparable<>)
		- Thus you can create Compable
		- implements compare(myClass x, myClass2 y) for your custom logic
		- used for Collections.sort(<insert compare implementation>)
		
		

Serialization/marshalling :
	- Note: When a program is executing code the objects are in some format, in memory, readable by the
		language (maybe bytecode for the JVM). (ie, executable code)
	- A serialized object can be used for communication; for storage or sent over the internet
	- Cannot be processed by a computer program. 		
	- serialization converts object to stream of bytes,
	- but in serialization, it's more like the object's members are 'flattened' to a string.
	- JSON, YAML, or XML
Deserialization/unmarshalling:
	- Unmarshalling takes the serialized object and transforms it into an executable form.
		
		
		
??		
	-Babel is simply a translator, who translates your 'fancy' (ES6+) JS code into 'not-so-fancy' (ES5) ones that browser 
(front-end) or Node.js (back-end) understands.
	- @autowired in spring is for implicit dependecy injection
	- concurrency = multiple threads in parrael
		
Checked vs Unchecked		
	(recall)
		- when an error occurs within a method, the method creates an object (of subtype Throwable) and hands it off to the 
			runtime system. The object, called an exception object.
	Checked
		- Java compiler forces you to handle checked expections. 
		- "throws" "try-catch"
		- Checked exceptions are checked at compile-time. It means if a method is throwing a checked exception then it should handle the 
	exception using try-catch block or it should declare the exception using throws keyword, 
		- denotes errors outside the control of the program. 
			- They occur when interacting with outside resources/network resources 
			- e.g. database, network, missing files etc.
		
	Unchecked
		- Uncheck are exceptions that occur in the programs but are not handled. Usually null errors
		
		
DEPENDENCY INJECTION II
	- dependcy = a class needs/requires/depends another object inotrdder to function properly
	- Dependency injection is all about removing hard-coded dependencies from your classes
	https://www.c-sharpcorner.com/article/dependency-injection-part-3/
	
	Explicit Dependencies
	- the class exposes it's dependencies in it's constructor. (sometimes in method parameter)
	- an explicit dependency is often an interface in the class constructor.
		- so it's loosely coupled
		- so the depeendency cn be swapped out easily with other implementations, wherhe production, testing, or debugging.
	Implicit Dependencies
	- the class's dependencies are created in the class, and exist only in the code within that class.
		- tightly coupled
		- more difficult to test and more to maintain
		
	- in Spring, Autowired is useful for dependency injection, saves you time by automatically doing the wiring
		(instead of you doing the work in the XML)
	- https://stackoverflow.com/questions/19414734/understanding-spring-autowired-usage
		
	ex)
	public class Customer {
	
		//dependencey
		Service service;
		
		public Customer(Service service){
			this.service = service
		}
		
		public String writeCustomerService(){
			println(service.getName()) // assume getName() exists elsewhere
			return service.getName()
		}
	}
		
INVERSION OF CONTROL II
	- classes should configure it's dependencies from the outside
	- recall, ideally java classes should be as independent as possible
		- reuse and test
	
	
SQL vs NoSQL
    SQL 
        difficult to scale 
            - requires bigger machines (vertical) cant than multiple machines
            - more CPU, RAM or SSD
        schemas
            - structure of data is known in advacne
            - (need to define schemas before hand)
        - flexibility
            good for complex queries
        EX) PostgreSQL, Cassandra Microsoft SQL Server, MySQL, Oracle Database
    NoSQL  
        no schemas
            - can add fields as you go, do not need to define their strucutre
            - simple low level queries (simple)
            - data is nested, like JSON feel
            
Latency = time to get from point a to b ---> lower = good --->  ping 
bandwidth = amount transfered over time (like bigger width ---> more stuff passes through the pipes)
IOPs = number of transfers per second = Input/Output Per Second 
            
            
Static code Analysis vs Dynamic code Analysis        
    Static:
      - performed without actually executing programs, 
    Dynamic:
      - which is analysis performed on programs while they are executing
    
    
Code Refactoring
    - restructuring existing code without changing its functionality. 
    - intended to improve the design and structure (its non-functional attributes)
    - eg) improved code readability and reduced complexity;
	
Higher Order Functions
    - a function that receives a function as an argument 
    - or returns the function as output.
    - eg)  Array.prototype.map, Array.prototype.filter and Array.prototype.reduce 
 
Composition 
    - instead of inheriting properties, the class is composed of objects with the properties built in
    - you can change functionality of objects at runtime
    
    
Severless (aka Faas - Function-aaS or Backend-aaS)
    - Applications are hosted by a 3rd party service, eliminating the need for a server software or hardware
    - eg) Amazon Lambda
    - Pay for use
    - Pros: apparently its cheapers, and scales
    - Cons: get locked in to Vender (Lambda), not efficent for long-running applciations
    
Domain Driven Design
    ???
    

    
SOLID
    Single Responsibitly
        - every module or class should have responsibility over a single part of the functionality
    Open-Closed 
        - Every class, module, function, ect should be open for extension but clsoed for modification
        - adding new functionality by writing new  classes, methods, ect instead of changing existing ones
    Liskov substitution principle
        - every subclass class should be substitutable for their base class.
        - Objects in a program should be replaceable with instances of their subtypes without altering the correctness of that 
            program
    Interface segregation principle
        - Many client-specific interfaces are better than one general-purpose interface
        - no client should be forced to depend on methods it does not use.
            - b/c the dev will be forced to implement methods (since interface) that are there only b/c the language requires it
            - eg) @Override doSomething() { print("lol does nothing") }
        - so you must define your interfaces so that they fit a specific client or task.
        
    Dependency Inversion principle
        - Depend on Abstraction not on concretions
        - High-level modules should not depend on low-level modules. Both should depend on abstractions (e.g. interfaces).
        - things should be modular and not tightly coupled and abstraction
        - eg) strategy pattern, dependency injection (I think)
        
Build Automation 
    - automating the creation of a software build 
    - build = compiling and running automated tests
    build automation utiltiy
        - CMake, Maven, Gradle, ect 
    build automation server
        - Jenkins, CircleCI
        
    
####################	
windows measure process runtime 
 Measure-Command { start-process python .\cheekyNoPrint.py -Wait}
 ###############
 
 
 Javascript (random)
    .call()
    
    With call(), an object can use a method belonging to another object.
    The call() method calls a function with a given *this* value and arguments provided individually.
    .call(thisArg) ---> thisArg = The value to use as *this* when calling func.
    
            var person = {
              fullName: function() {
                return this.firstName + " " + this.lastName;
              }
            }
            var person1 = {
              firstName:"John",
              lastName: "Doe"
            }
            var person2 = {
              firstName:"Mary",
              lastName: "Doe"
            }
            person.fullName.call(person2);  // Will return "Mary Doe"

    Callback:
    A callback is a function that is to be executed after another function has finished executing

    freeze():
    - Object.freeze() method freezes an object. 
    - can't be changed, prevents new properties to be added, prevnet existing properties from being removed,
    const vs freeze()
    - const should be used on primatives.
    - const makes the address unchangable (iirc), but this means you can mess with properties, "myUser.name = 'john'"    
    - freeze should be used on objects.
    - properties on an objecnt cant be changed "myUser.name = 'john'" // doesnt work
    
    
    Lambda vs Arrow Function
    - Same thing, different syntax
    - Javascript lambda: 
        var anon = function (a, b) { return a + b };
    - ES6 lambda
        var anon = (a, b) => { return a + b };
        
    Treeshaking
    - the removal of dead code.
    - elies on the import and export statements in ES2015 to detect if code modules are exported and imported between files. 
 
    Prototype
    - every object has __proto__ (can verify in google/firefox webdebugger)
    - the __proto__ has all the methods attatched to that object
    - you can put functions in Prototype instead  of in the "class funky() { ... } "
    - They both work on the function the same, but the Prototype allows for inheritence and possibly small objects (since they all 
        point to prototype function instead of theri own internal function)
    - calling a function will check __proto__ and chain up
    eg) 
        funky.Prototype.myCoolFunction = function(a,b) { ... }
    
 
 Java (random)
    
    Anonymous class:
    - when you create an object you could make an new class on the fly
    - the curly braces {} is the syntax that allows the program to extend & instantiate a new class
    
    eg) 
        class MyClass() { ..... }
        MyClass x = new MyClass() { .... }
        // x is an extension of MyClass 
        // this object x is a subclass and it has no name
        
    Anonymous class with interface:
    - double braces
    - create an object of IFaceman which also has the implemenation of  IFaceMan
    - you create the anonymous class and it gets the implimentation
    - good for when you use the interface only once
    
    eg)
        interface IFaceman { 
            void show() }
        IFaceMan x = new IFaceman() { { public void show() {....} } }
 
    Functional Interface
    - java syntax 'trick' 
    - when an interface has just 1 method, you could use a lambda 
        
        interface IFaceman { void show() }
        IFaceMan x = () -> System.out.println("Hi");
 
    Interface 
    - in it, all functions are abstract. (even if they do not have the abstract keyword)
        - unless the function is defined as a default method or static method
    Interface as Type
    - ie) Interface reference type
    - like variables of class type, you can create variables of an interface type, but objects assigned to interface type 
        variables must be instances of a class that implemented the interface
    - But unlike class, you cannot create objects of an interface type, you can only refer objects using interface variable.
    eg) IBlocker block;
        block = new Tinfoil() // elsewhere... class Tinfoil implements block
        // block has only the IBlocker methods in Tinfoil but not any more
        
    Reflection
        - is a library 
        - code that can look at itself
        - refelction = class manipulator
        - manipulates a class and everything in a class (private methods, private fields, ect)
        - canot be used with applets b/c applets find reflection dangerous / not secure
        - slow
        
 
 DESIGN PATTERNS II
    Design patterns - solutions  to common problems
                    - template that could be modified to solve your problem
                    - 3 types: behavior, structrual, design
 
    Factory Pattern:
        - used to create objects 
        - a creational design pattern that uses factory methods to create objects — rather than by calling a 
            constructor.
        - likely uses a personFactory() object, with a .create(name, type)  method.
    
    Singleton Pattern:
        - 1 instance only
        - if you try to create two singletons, you will actually only get 1 object and they are both the same object
        - likely, in the class there is an object which is created once (1st time) and the constructor* will check if 
            that object exists, if does return it otherwise (in 1st run) create it. 
            *(or s/t similar, depending on lanague)
    
    Strategy Pattern:
        - group of interchangable functions, ie strategies. strategy = function
        - can change behavior at runtime
        - easy to swap 
        - likely, you'll have multiple classes (a,b) which implements the same interface
            - and you'll have another class (Strat) which implements those classes (a,b)
            - Strat can swap strategies/alogithms/functions with setStrategy()
            - recal OOP Composition
    
    Iterator Pattern:
        - lets to loops over a collection of objects (arrays, graph or tree)
        - has this.items and this.index
        - has two methods:
            - hasNext() (if index < items.length)
            - next() (get at index & increment)
    
    Observer Pattern:
        - the subject (publisher) notifies/triggers  many observers (subscribers)
            - usually by calling 1 method "update()"
        - 1 subject, many observers
        - subject class has a list of observers and a 'notify' or 'updateAll' method
        - will have a observer interface w/ "update()" method
        - any class which you want to be notified/updateAll will implement Obsever interface 
            - then add it to your subject object
            
    Proxy Pattern:
        - is a wrapper that wraps around some api with a 'getData()' method
        eg) 
            class CryptoAPI() { getValue("money-money")}
            class CryptoProxy() {   this.api = new CryptoApi("money-money"); 
                                    this.hashMap = {}      
                                   //code that checks if money-money exists before calling API  }
        
        - has a hash map or single variable for the getData("Micheal Jackson")
        - checks if this.data["Micheal Jackson"] exists, if not then do fetch assign this.data["Micheal Jackson"]
        - could interface to anything (presumably s/t expensive):
            - a network connection, api calls, a file, or other resource e
        
    Mediator Pattern
        - central autheority through which different components can communicate
        - defines a object (mediator) that controls how some set of objects interacts w/ each other
        - you have 3 objects that need to communicate w/ each other,
            - instead of sending info directly to and from each other they send messages to 1 mediator object
            - the mediator handles the logic & routing to do (mediate) the communication
        - likely, you'll have a single mediator and few participants (name I coined)
            - the participants has a mediator object, probably sent via constructor
            - maybe the mediator also has a list of participants
            
        ex ) chatroom
            
            
    Visitor Pattern
        - add new methods to a class without changing the class.
        - the methods are kept in a visitor object
            - the object that you want to extend with more methods must implement a accept() method
        - you pass a visitor object that implements these operation are passed 
        - likely you'll have mutliple visitor class types (gasVisitor, hotelVisitor) which extend some visitor interface
        - and you'll have multple classes with an accept() method 
            - the accept method takes a function/interface in its parameter as passes "this", the reference of the current Employee

    Factory Pattern 
        - creates objects at runtime.
        - a CoolFactory class will build/return objects based on some string or int sent into the parameter.
        - eg) CoolGuy snoop = CoolFactory.build("Snoop Dogg")
        
    Builder Pattern
        - good for constructing complex objects 
        - it builds the object step by step then a build() method will return the object.
        - likely, lots of setName(), setAge(), each which returns "this", the UserBuilder object
            - then build() returns this.user
        - eg) let user = new UserBuilder("Bob").setAge(12).setPhone("3031123123").build()
            
    Protype Pattern
        - used when creation of object directly is costly
        - clone objects via the .clone() method by extending the Clonable class
        - its all via .clone() method instead of "dog = new Doggy()"
        - likely use a hashmap that contains multiple pre-loaded object or maybe a cloneFactory that takes in the object 
            - calls .clone() on these
        - cache object and returns its clone on next request (thus reducing database calls).
            - like an object that is created after a costly database operation.
            
    Decorator Pattern 
        - good for when you want to add functionality at run time
        - more flexible than inheritance
        - add fuctionality by using many many simple classes
        - likely, you'll have 3 classes:
            - a interface Car, BasicCar implements Car, and CarDecorator implements Car,
            - then as many extra classes that extend the CarDecorator. LuxuryCare, SportCar, ect
                - each with a 1 line constructor "super(myCar)"
        - eg) Car sportsCar = new SportsCar(new BasicCar());
              Car sportsLuxuryCar = new SportsCar(new LuxuryCar(new BasicCar()));
              sportsCar.assemble();
        - 
            
            
            
            
            
    
    
    
    
    